1. Что такое range()?


1) Range() - функция питона для создания списков (list) содержащих арифметическую прогрессию. Чаще всего она используется в циклах for. Функция range() может принимать от одного до трех агрументов, при этом аргументами должны быть целые числа (int). range(старт, стоп, шаг) - так выглядит стандартный вызов функции range() в Python. По умолчанию старт равняется нулю, шаг единице.


2. Что такое менеджеры контекста?


2) Менеджеры контекста - объект Python, который выполняет за вас рутинную работу, когда вы используете определённые ресурсы. В частности, менеджер контекста задаёт временный контекст и ликвидирует его после выполнения операций. Менеджер контекста открывает файл и создаёт объект, с которым дальше будет производиться работа. Когда мы завершим операцию и любые исключения, выброшенные в процессе выполнения операции, менеджер контекста закроет файл. Поскольку файлы являются совместно используемыми ресурсами и находятся в вашей ответственности (задачу управления ими помогают решать менеджеры контекста), критически важно, чтобы вы освободили их после того, как выполните операции, чтобы другие процессы получили к ним доступ.


3. Что такое итератор?


3) Итератор - объект, основное их назначение – это упрощение навигации по элементам объекта, который, как правило, представляет собой некоторую коллекцию


4. Методы класса.


4) Методы класса - методы, которые привязаны к самому классу, а не его экземпляру. Они могут менять состояние класса, что отразится на всех объектах этого класса, но не могут менять конкретный объект.
Встроенный пример метода класса — dict.fromkeys()— возвращает новый словарь с переданными элементами в качестве ключей.


5. Методы экземпляра класса.


5) Методы экземпляра класса - вид методов, принимают объект класса как первый аргумент, который принято называть self и который указывает на сам экземпляр. Количество параметров метода не ограничено.
Используя параметр self , мы можем менять состояние объекта и обращаться к другим его методам и параметрам. К тому же, используя атрибут self.__class__ , мы получаем доступ к атрибутам класса и возможности менять состояние самого класса. То есть методы экземпляров класса позволяют менять как состояние определённого объекта, так и класса.Встроенный пример метода экземпляра — str.upper().


6. Порождающие шаблоны в Python.


6) Factory - Фабрики используются для инкапсуляции информации о классах, и при этом для создания их экземпляров на основе определенных параметров, которые им предоставляются.

Используя фабрику, можно поменять реализацию одну на другую, просто изменив параметр, который использовался для первоначального определения исходной реализации.

Это отделяет реализацию от использования таким образом, что мы можем легко масштабировать приложение, добавляя новые реализации и просто создавая их экземпляры через фабрику — с точно такой же кодовой базой.

Если мы просто получим другую фабрику в качестве параметра, нам даже не нужно будет знать, какой класс она производит. Нам просто нужен метод единой фабрики, который возвращает класс с гарантированным набором поведений. Давайте создадим фабрику.


    Abstract Factory - Абстрактная фабрика отвечает за создание целых групп объектов, наряду с их соответствующими фабриками, — но она не касается конкретных реализаций этих объектов.

    
    Builder - создает наш объект и добавляет соответствующие модули нашему роботу. Вместо замысловатого конструктора мы можем создать экземпляр объекта и добавить необходимые компоненты с помощью функций.
Мы вызываем конструкцию каждого модуля отдельно, после создания объекта.


7. Структурные шаблоны в Python.


7) Компоновщик — это структурный паттерн, который позволяет создавать дерево объектов и работать с ним так же, как и с единичным объектом.


   Мост — это структурный паттерн, который разделяет бизнес-логику или большой класс на несколько отдельных иерархий, которые потом можно развивать отдельно друг от друга.


   Адаптер — это структурный паттерн, который позволяет подружить несовместимые объекты.


8. Поведенческие шаблоны в Python.


8) Снимок — это поведенческий паттерн, позволяющий делать снимки внутреннего состояния объектов, а затем восстанавливать их.


   Посетитель — это поведенческий паттерн, который позволяет добавить новую операцию для целой иерархии классов, не изменяя код этих классов.


   Посредник — это поведенческий паттерн, который упрощает коммуникацию между компонентами системы.


9. Зачем нужны магические методы Python?


9) Одним из самых больших преимуществ использования магических методов Python является то, что они обеспечивают простой способ заставить объекты вести себя как встроенные типы. Это означает, что вы можете избежать нестандартных способов выполнения основных операторов, и облегчают использование объектов.


10. Виды awaitable object.


10) Есть три варианта awaitable объектов:
Другая сопрограмма, а именно объект native coroutine. Этот напоминает, и видимо реализовано аналогично случаю, когда в генераторе с помощью yield from вызывается другой генератор.
Сопрограмма на основе генератора, созданная с помощью декоратора types.coroutine(). Это вариант обеспечения совместимости с наработками, где сопрограммы реализованы на основе генераторов.
Специальный объект, у которого реализован магический метод __await__, возвращающий итератор. С помощью этого итератора реализуется возврат результата выполнения сопрограммы.


11. Виды async.


11) Есть три варианта async:

	async def — определяет native coroutine function, результатом вызова которой будет объект-сопрограмма native coroutine, пока еще не запущенная.

	async for — определяет, что итератор используемый в цикле, при получении следующего значения может переключать выполнение с текущей сопрограммы. Объект итератор имеет вместо стандартных магических методов: __iter__ и __next__, методы: __aiter__ и __anext__. Функционально они аналогичны, но как следует из определения, допускают использования await в своем теле.

	async with — определяет, что при входе в контекстный блок и выходе из него может быть переключение выполнения с текущей сопрограммы. Так же, как и в случае с асинхронным генератором, вместо магических методов: __enter__ и __exit__ следует использовать функционально аналогичные __aenter__ и __aexit__.


12. Множественное наследование.


12) Множественное наследование - это естественное расширение концепции простого наследования, когда класс автоматически делегирует разрешенные метода и атрибуты другому классу 


13. Что такое миксины?


13) Mixin классы - это концепция в программировании, в которой класс предоставляет функциональные возможности, но не предназначен для самостоятельного использования. Основная цель миксинов - предоставить какие-то дополнительные методы.

Другими словами классы миксины или как еще их называют примеси - это ограниченная форма множественного наследования. В частности, в контексте языка Python, миксин - это родительский класс, который предоставляет функциональные возможности подклассам, но не предназначен для создания экземпляров самого себя. И было бы лучше, если бы сами миксины не имели наследования от других миксинов, а также избегали какого либо состояния.

В Python нет какого либо специального синтаксиса для поддержки миксинов, по этому классы миксинов, легко можно перепутать с обычными классами, но при этом у них действительно очень большая как семантическая, так и реальная разница с обычными классами.


14. Достоинства и недостатки многопоточности.


14) Плюсы многопоточности:

Multithreading может значительно повысить скорость вычислений в многопроцессорных или многоядерных системах, поскольку каждый процессор или ядро обрабатывает отдельный поток одновременно.

Multithreading позволяет программе оставаться отзывчивой, пока один поток ожидает ввода, а другой одновременно запускает графический интерфейс. Это утверждение справедливо как для многопроцессорных, так и для однопроцессорных систем.

Все потоки процесса имеют доступ к его глобальным переменным. Если глобальная переменная изменяется в одном потоке, она видна и другим потокам. Поток также может иметь свои собственные локальные переменные.

Минусы многопоточности:

В однопроцессорной системе многопоточность не влияет на скорость вычислений. Фактически производительность системы может снизиться из-за накладных расходов на управление потоками.

Синхронизация необходима, чтобы избежать взаимного исключения при доступе к общим ресурсам процесса. Это напрямую ведет к увеличению использования памяти и процессора.

Многопоточность увеличивает сложность программы, что также затрудняет отладку.
Это повышает вероятность потенциальных ошибок.

Это может вызвать голод, когда поток не получает регулярный доступ к общим ресурсам. Тогда он не сможет возобновить свою работу.


15. Что такое DNS?


15) Сервер доменных имён — это устройство, которое сопоставляет имя хоста с IP-адресом конкретной машины/железа. DNS-резолвер
Это компьютеры, которые провайдеры используют для поиска в их базе данных конкретного узла, запрашиваемого пользователем. Когда данные получены, пользователь перенаправляется на соответствующий IP-адрес. 
Типы DNS-серверов: 

Корневой DNS-сервер
Это DNS-сервер, который хранит в себе адреса всех TLD-серверов (TLD — top-level domain, домен верхнего уровня). По пути от имени хоста до IP-адреса запрос сначала попадает на корневой DNS-сервер.

TLD-серверы
Эти серверы связаны с доменами верхнего уровня (TLD). Обычно они идут после корневых DNS-серверов. В TLD-серверах содержится информация о домене верхнего уровня конкретного хоста.

Авторитативный DNS-сервер
Запрос на эти серверы поступает в самую последнюю очередь. Эти серверы хранят фактические записи типа A, NS, CNAME, TXT, и т. п.

Типы DNS-запросов:

Рекурсивный: подобные запросы выполняют пользователи к резолверу. Собственно, это первый запрос, который выполняется в процессе DNS-поиска. Резолвером чаще всего выступает ваш интернет провайдер или сетевой администратор.

Нерекурсивные: в нерекурсивных запросах резолвер сразу возвращает ответ без каких-либо дополнительных запросов на другие сервера имён. Это случается, если в локальном DNS-сервере закэширован необходимый IP-адрес либо если запросы поступают напрямую на авторитативные серверы, что позволяет избежать рекурсивных запросов.

Итеративный: итеративные запросы выполняются, когда резолвер не может вернуть ответ, потому что он не закэширован. Поэтому он выполняет запрос на корневой DNS-сервер. А тот уже знает, где найти фактический TLD-сервер.


16. Что такое декоратор функции в Python?


16) Декоратор представляет собой некоторую функцию, аргументом которой является другая функция. Декоратор предназначен для добавления дополнительного функционала к данной функции без изменения содержимого последней.
Декоратор — это паттерн проектирования (design pattern) в Python, а также функция второго уровня, то есть принимающая другие функции в качестве переменных и возвращающая их, в сам декоратор, и в функцию-обёртку, можно передать и позиционные, и именованные аргументы — args и kwargs соответственно. Декораторы работают не только с функциями, но и с классами и методами.


17. Что такое ORM в Python?


17) Объектно-реляционный преобразователь (ORM) - это библиотека кода, которая автоматизирует перенос данных, хранящихся в таблицах реляционной базы данных, в объекты,которые используются в коде приложения.

Чем полезны ORM? ORM предоставляют высокоуровневую абстракцию реляционной базы данных, которая позволяет разработчику писать код Python вместо SQL для создания, чтения, обновления и удаления данных и схем в своей базе данных. Разработчики могут использовать язык программирования, который им удобен, для работы с базой данных вместо написания операторов SQL или хранимых процедур.

Возможность писать код Python вместо SQL может ускорить разработку веб-приложений, особенно в начале проекта. Потенциальное повышение скорости разработки связано с отсутствием необходимости переключаться с кода Python на написание операторов SQL с декларативной парадигмой.


18. Что такое list comprehension?


18) List comprehension — это упрощенный подход к созданию списка, который задействует цикл for, а также инструкции if-else для определения того, что в итоге окажется в финальном списке.

Преимущества list comprehension
У list comprehension есть три основных преимущества.

Простота. List comprehension позволяют избавиться от циклов for, а также делают код более понятным. В JavaScript, например, есть нечто похожее в виде map() и filter(), но новичками они воспринимаются сложнее.

Скорость. List comprehension быстрее for-циклов, которые он и заменяет. Это один из первых пунктов при рефакторинге Python-кода.

Принципы функционального программирования. Это не так важно для начинающих, но функциональное программирование — это подход, при котором изменяемые данные не меняются. Поскольку list comprehensions создают новый список, не меняя существующий, их можно отнести к функциональному программированию.


19. Как работают декораторы?


19) Функция-декоратор она принимает в качестве аргумента другую функцию. Затем с этой функцией что-то делают внутри вложенной функции-обёртки и возвращают из декоратора уже обёртку вместо исходной функции.


20. Что такое TDD?


20) TDD - техника разработки программного обеспечения, которая основывается на повторении очень коротких циклов разработки: сначала пишется тест, покрывающий желаемое изменение, затем пишется код, который позволит пройти тест, и под конец проводится рефакторинг нового кода к соответствующим стандартам.

Разработка через тестирование требует от разработчика создания автоматизированных модульных тестов, определяющих требования к коду непосредственно перед написанием самого кода. Тест содержит проверки условий, которые могут либо выполняться, либо нет. Когда они выполняются, говорят, что тест пройден. Прохождение теста подтверждает поведение, предполагаемое программистом. 

Разработчики часто пользуются библиотеками для тестирования (англ. testing frameworks) для создания и автоматизации запуска наборов тестов. На практике модульные тесты покрывают критические и нетривиальные участки кода. Это может быть код, который подвержен частым изменениям, код, от работы которого зависит работоспособность большого количества другого кода, или код с большим количеством зависимостей.


21. Какие есть способы выполнять код?


21) Синхронный и асинхронный:

В ​синхронных операциях задачи выполняются друг за другом. В асинхронных задачи могут запускаться и завершаться независимо друг от друга. Одна асинхронная задача может запускаться и продолжать выполняться, пока выполнение переходит к новой задаче. Асинхронные задачи ​не блокируют (не заставляют ждать завершения выполнения задачи) операции и обычно выполняются в фоновом режиме.

Например, вы должны обратиться в туристическое агентство, чтобы спланировать свой следующий отпуск. Вам нужно отправить письмо своему руководителю, прежде чем улететь. В синхронном режиме, вы сначала позвоните в туристическое агентство, и если вас попросят подождать, то вы будете ждать, пока вам не ответят. Затем вы начнёте писать письмо руководителю. Таким образом, вы выполняете задачи последовательно, одна за одной. [синхронное выполнение, прим. переводчика] Но, если вы умны, то пока вас попросили подождать [​повисеть на телефоне, прим. переводчика] вы начнёте писать e-mail и когда с вами снова заговорят вы приостановите написание, поговорите, а затем допишете письмо. Вы также можете попросить друга позвонить в агентство, а сами написать письмо. Это асинхронность, задачи не блокируют друг друга.

Конкурентность и параллелизм:

Конкурентность подразумевает, что две задачи выполняются совместно. В нашем предыдущем примере, когда мы рассматривали асинхронный пример, мы постепенно продвигались то в написании письма, то в разговоре с тур. агентством. Это ​конкурентность.

Когда мы попросили позвонить друга, а сами писали письмо, то задачи выполнялись ​параллельно.​

Параллелизм по сути является формой конкурентности. Но параллелизм зависит от оборудования. Например, если в CPU только одно ядро, то две задачи не могут выполняться параллельно. Они просто делят процессорное время между собой. Тогда это конкурентность, но не параллелизм. Но когда у нас есть несколько ядер [как друг в предыдущем примере, который является вторым ядром, прим. переводчика] мы можем выполнять несколько операций (в зависимости от количества ядер) одновременно.

Подытожим:

Синхронность: блокирует операции (блокирующие)
Асинхронность: не блокирует операции (неблокирующие)
Конкурентность: совместный прогресс (совместные)
Параллелизм: параллельный прогресс (параллельные)


22. Как работают сигналы в Django?


22) Django содержит “диспетчер сигналов”, который позволяет одним приложениям фреймворка получать уведомления от других после того, как в последних произойдут некоторые события. Вкратце, сигналы позволяют определённым отправителям уведомлять некоторый набор получателей о совершении действий. Сигналы особенно полезны, когда поведение многих фрагментов кода зависит от инициации одних и тех же событий.

Django предоставляет набор встроенных сигналов, которые позволяют пользовательскому коду получать уведомление от Django об определённых событиях.


23. Как в request появляется атрибут user?


23) Атрибут request.user для каждого запроса, который возвращает текущего пользователя. Если текущий пользователь не авторизован, атрибут содержит экземпляр AnonymousUser, иначе экземпляр User.

Различить их можно с помощью метода is_authenticated().


24. Что такое дата миграции django?


24) Дата-миграции — это особые миграции, которые не трогают структуру таблиц, но меняют данные в них. Дата-миграции позволяют автоматически рассчитать какое-нибудь поле или, например, перенести данные из одной таблицы в другую. Обычные миграции (их ещё называют схема-миграции) и дата-миграции вместе берут на себя всю работу с данными в Django. Освоив эти два инструмента вы получите полную свободу в плане хранения данных. Django использует миграции для переноса изменений в моделях (добавление поля, удаление модели и т.д.) на структуру базы данных. Миграции создавались в основном для автоматической работы, но вам необходимо знать когда их создавать, запускать и как решать различные проблемы.


25. Как работает бинарный поиск?


25) Двоичный, или бинарный, поиск значения в списке или массиве используется только для упорядоченных последовательностей, то есть отсортированных по возрастанию или убыванию. Заключается в определении, содержит ли массив искомое значение, а также в определение места его нахождения.

Описание алгоритма
Находится средний элемент последовательности. Для этого первый и последний индексы связываются с переменными, а индекс среднего элемента вычисляется.

Значение среднего элемента сравнивается с искомым значение. В зависимости от того, больше оно или меньше значения среднего элемента, дальнейший поиск будет происходить только в левой или только в правой половинах массива. Если значение среднего элемента оказывается равным искомому, поиск завершается.

Иначе одна из границ исследуемой последовательности сдвигается. Если искомое значение больше значения среднего элемента, то нижняя граница сдвигается за средний элемент на один элемент справа. Если искомое значение меньше значения среднего элемента, то верхняя граница сдвигается на элемент перед средним.

Снова находится средний элемент теперь уже в выбранной половине. Описанный выше алгоритм повторяется для данного среза.


26. Сортировка вставками


26) Сортировка вставками (Insertion Sort) простой алгоритм, часто используется при изучение компьютерных наук и обычно, является одним из первых алгоритмов сортировки, с которым знакомя учеников. Он интуитивно понятен и прост в реализации, но он очень медленный для больших массивов и поэтому почти никогда не используется для сортировки реальных данных.

Insertion Sort является stable и in-place алгоритмом, который действительно хорошо работает только для почти отсортированных или небольших массивов.

Что значит stable и in-place:

in-place: Требует небольшого постоянного дополнительного пространства памяти (независимо от входного размера коллекции),он перезаписывает исходные ячейки памяти элементов в коллекции.
stable: Алгоритм поддерживает относительный порядок равных объектов из исходного массива.

Массив разбивается на «отсортированный» подмассив и «несортированный» подмассив. В начале отсортированный подмассив содержит только первый элемент нашего исходного массива.

Первый элемент в несортированном массиве оценивается так, что мы можем вставить его на свое место в отсортированном подмассиве.

Вставка выполняется путем перемещения всех элементов которые больше, чем новый элемент, на одну позицию вправо.

Это продолжается, пока весь наш массив не будет отсортирован.

Имейте в виду, однако, что когда мы говорим, что элемент больше или меньше, чем другой элемент — это не обязательно означает большие или меньшие целые числа.

Мы можем определить слова «больше» и «меньше», как нам нравится при использовании пользовательских объектов. Например, точка A может быть «больше», чем точка B, если она находится дальше от центра системы координат.


27. Что такое паттерны проектирования?


27) Паттерны проектирования = шаблоны проектирования.


28. Что такое транзакция?


28) Транзакция — это единица работы (unit of work), затрагивающая набор операций базы данных.

Транзакции PostgreSQL обрабатываются объектом соединения. Он отвечает за сохранение изменений или откат в случае неудачи.

С помощью объекта cursor выполняются операции в базе данных. Можно создать неограниченное количество объектов cursor из объекта connection. Если любая из команд объекта cursor завершается неудачно, или же транзакция отменяется, то следующие команды не выполняются вплоть до вызова метода connection.rollback().

Объект соединения отвечает за остановку транзакции. Это можно сделать с помощью методов commit() ли rollback().
После использования метода commit() изменения сохраняются в базе данных.
С помощью метода rollback() можно откатить изменения.
Connection.autocommit
По умолчанию соединение работает в режиме автоматического сохранения, то есть свойство auto-commit равно True. Это значит, что при успешном выполнении запроса изменения немедленно сохраняются в базу данных, а откат становится невозможным.

Для выполнения запросов в транзакции это свойство нужно отключить. Для этого нужно сделать connection.autocommit=False. В этом случае будет возможность откатить выполненный запрос к оригинальному состоянию в случае неудачи.

Connection.commit
Если все операции в транзакции завершены, используйте connection.commit() для сохранения изменений в базе данных. Если метод не использовать, то все эффекты взаимодействия с данными не будут применены.

Connection.rollback
Если в транзакции хотя бы одна операция завершается неудачно, то отменить изменения можно с помощью connection.rollback().


29. Виды оператора JOIN


29)- INNER JOIN - Оператор внутреннего соединения INNER JOIN соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является коммутативным.

Заголовок таблицы-результата является объединением (конкатенацией) заголовков соединяемых таблиц.

Тело результата логически формируется следующим образом. Каждая строка одной таблицы сопоставляется с каждой строкой второй таблицы, после чего для полученной «соединённой» строки проверяется условие соединения (вычисляется предикат соединения). Если условие истинно, в таблицу-результат добавляется соответствующая «соединённая» строка.

- OUTER JOIN - Соединение двух таблиц, в результат которого обязательно входят все строки либо одной, либо обеих таблиц.

- LEFT OUTER JOIN - Оператор левого внешнего соединения LEFT OUTER JOIN соединяет две таблицы. Порядок таблиц для оператора важен, поскольку оператор не является коммутативным.

Заголовок таблицы-результата является объединением (конкатенацией) заголовков соединяемых таблиц.

Тело результата логически формируется следующим образом. Пусть выполняется соединение левой и правой таблиц по предикату (условию) p.

В результат включается внутреннее соединение (INNER JOIN) левой и правой таблиц по предикату p.
Затем в результат добавляются те строки левой таблицы, которые не вошли во внутреннее соединение на шаге 1. Для таких строк столбцы, соответствующие правой таблице, заполняются значениями NULL.

- RIGHT OUTER JOIN
Оператор правого внешнего соединения RIGHT OUTER JOIN соединяет две таблицы. Порядок таблиц для оператора важен, поскольку оператор не является коммутативным.

Заголовок таблицы-результата является объединением (конкатенацией) заголовков соединяемых таблиц.

Тело результата логически формируется следующим образом. Пусть выполняется соединение левой и правой таблиц по предикату (условию) p.

В результат включается внутреннее соединение (INNER JOIN) левой и правой таблиц по предикату p.
Затем в результат добавляются те строки правой таблицы, которые не вошли во внутреннее соединение на шаге 1. Для таких строк столбцы, соответствующие левой таблице, заполняются значениями NULL.

- FULL OUTER JOIN
Оператор полного внешнего соединения FULL OUTER JOIN соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является коммутативным.

Заголовок таблицы-результата является объединением (конкатенацией) заголовков соединяемых таблиц.

Тело результата логически формируется следующим образом. Пусть выполняется соединение первой и второй таблиц по предикату (условию) p. Слова «первой» и «второй» здесь не обозначают порядок в записи выражения (который неважен), а используются лишь для различения таблиц.

В результат включается внутреннее соединение (INNER JOIN) первой и второй таблиц по предикату p.
В результат добавляются те строки первой таблицы, которые не вошли во внутреннее соединение на шаге 1. Для таких строк столбцы, соответствующие второй таблице, заполняются значениями NULL.
В результат добавляются те строки второй таблицы, которые не вошли во внутреннее соединение на шаге 1. Для таких строк столбцы, соответствующие первой таблице, заполняются значениями NULL.


30. Как работают JOIN-ы?


30) SQL JOIN всегда соединяет две таблицы и ищет связанные объекты, отвечающие заданным правилам (обычно, хотя и не обязательно, равные значения). Можно соединить несколько таблиц. Например, чтобы соединить три таблицы, потребуется 2 JOIN. Для каждой следующей таблицы потребуется еще один JOIN. Таким образом, чтобы соединить N таблиц, потребуется N-1 JOIN.

Важно, что SQL позволяет использовать в одном выражении разные типы соединений.


31. Зачем нужны и как работают индексы?


31) Индекс создается с целью повышения производительности поиска данных. Индекс формируется из значений одного или нескольких столбцов таблицы и указателей на соответствующие строки таблицы и, таким образом, позволяет искать строки, удовлетворяющие критерию поиска. Уникальный индекс реализует ограничение целостности на таблице, исключая возможность вставки повторяющихся значений.


32. Напишите запрос с GROUP BY.


32) SELECT model, COUNT(model) AS Qty_model, 

    AVG(price) AS Avg_price

FROM PC

GROUP BY model;


33. Что такое Redis и как работает?


33) Redis (Remote Dictionary Server) – это быстрое хранилище данных типа «ключ‑значение» в памяти с открытым исходным кодом. Redis обеспечивает время отклика на уровне долей миллисекунды и позволяет приложениям, работающим в режиме реального времени, выполнять миллионы запросов в секунду. Система работает сопоставляя ключи со значениями с помощью определенной модели. Хранение данных в оперативной памяти, а не на жестком диске.


34. Что такое nginx? 


34) Nginx (NGINX, Engine-X, «Энжин-кс») — это бесплатный веб- и почтовый прокси-сервер с непоточной (асинхронной) архитектурой и открытым кодом.


35. Что делает git cherry pick?


35) Команда git cherry-pick берёт изменения, вносимые одним коммитом, и пытается повторно применить их в виде нового коммита в текущей ветке. Эта возможность полезна в ситуации, когда нужно забрать парочку коммитов из другой ветки, а не сливать ветку целиком со всеми внесенными в нее изменениями.


36. Какие виды строк бывают в питоне?


36) Зависит от версии Питона. Во второй ветке два типа: однобайтные строки и Юникод представлены классами str и unicode соответственно. В третьем Питоне есть один вид строк str, который представляет собой Юникод. Однобайтных строк нет, вместо них есть тип bytes, то есть цепочка байт.


37. Можно ли изменить отдельный символ внутри строки?


37) Нет, строки неизменяемы. Операции замены, форматирования и конкатенации возвращают новую строку.


38. Как кодировать и декодировать строки?


38) Кодировать – перевести Юникод в байтовую строку. Вызвать метод .encode() у объекта unicode.

Декодировать – восстановить Юникод из цепочки байт. Вызвать метод .decode() у объекта str или bytes (версии Питона 2 и 3 соответственно).

В обоих случаях явно передавать кодировку, иначе будет использована та, что определена в системе по умолчанию. Быть готовым поймать исключения UnicodeEncodeError, UnicodeDecodeError.



39. Есть два списка – ключи и значения. Как составить из них словарь?


39) Функция zip отдает список пар N-ых элементов. Конструктор dict принимает список пар. Каждую пару он рассматривает как ключ и значение соответственно.


40. Где быстрее поиск элемента -— в списке или множестве?


40) Во множестве, потому что множество работает как словарь. Значение ищется по хешу ключа. Вычисление хеша и сопоставление адреса – операции постоянной сложности, поэтому принято говорить, что поиск в словаре равен O(1).

Исключение работает только для очень маленьких списков длиной до 5 элементов. В этом случае интерпретатору будет быстрей пробежаться по списку, чем считать хеш.


41. Что такое *args, **kwargs, в каких случаях они требуются?


41) Выражения *args и **kwargs объявляют в сигнатуре функции. Они означают, что внутри функции будут доступны переменные с именами args и kwargs (без звездочек). Можно использовать другие имена, но это считается дурным тоном.

args – это кортеж, который накапливает позиционные аргументы. kwargs – словарь позиционных аргументов, где ключ – имя параметра, значение – значение параметра.

Важно: если в функцию не передано никаких параметров, переменные будут соответственно равны пустому кортежу и пустому словарю, а не None.


42. Почему def foo(bar=[]): плохо? Приведите пример плохого случая. Как исправить?


42) Функция создается однажды при загрузке модуля. Именованные параметры и их дефолтные значения тоже создаются один раз и хранятся в одном из полей объекта-функции.

В нашем примере bar равен пустому списку. Список – изменяемая коллекция, поэтому значение bar может изменяться от вызова к вызову. Хорошим тоном считается указывать параметру пустое неизменяемое значение, например 0, None, '', False. В теле функции проверять на заполненность и создавать новую коллекцию. 


43. Можно ли передавать функцию в качестве аргумента другой функции?


43) Можно, функция в Питоне объект первого порядка: допускает присваивание, передачу в функцию, удаление.


44. Можно ли объявлять функцию внутри другой функции? Где она будет видна?


44) Можно. Такая функция будет видна только внутри первой функции.


45. Что может быть декоратором? К чему может быть применен декоратор?


45) Декоратором может быть любой вызываемый объект: функция, лямбда, класс, экземпляр класса. В последнем случае определите метод __call__.

Применять декоратор можно к любому объекту. Чаще всего к функциям, методам и классам. Декорирование встречается настолько часто, что под него выделен особый оператор @.


46. Что будет, если декоратор не возвращает ничего?


46) Если в теле функции нет оператора return, вызов вернет None. Помним, результат декоратора замещает декорируемый объект. В нашем случае декоратор вернет None и функция, которую мы декорируем, тоже станет None. При попытке вызвать ее после декорирования получим ошибку NoneType is not callable.


47. В чем отличие @foobar от @foobar()?


47) Первое – обычное декорирование функцией foobar.

Второй случай – декорирование функцией, которую вернет вызов foobar. По-другому это называется параметрический декоратор или фабрика декораторов. См. следующий вопрос.


48. Что такое фабрика декораторов?


48) Это функция, которая возвращает декоратор. Такой декоратор редко помещают в отдельную переменную. Вместо этого декорируют результатом вызова фабрики декораторов.

Например, вам нужен декоратор для проверки прав. Логика проверки одинакова, но прав может быть много.


49. Зачем нужен @wraps?


49) wraps – декоратор из стандартной поставки Питона, модуль functools. Он назначает функции-врапперу те же поля __name__, __module__, __doc__, что и у исходной функции, которую вы декорируете. Это нужно для того, чтобы после декорирования функция-враппер не выглядела в стектрейсах как исходная функция.


50. Как объявить генератор?


50) - использовать синтаксис (x for x in seq)
- оператор yield в теле функции вместо return
- встроенная функция iter, которая вызывает у объекта метод __iter__().


51. Как получить из генератора список?


51) Передать его в конструктор списка: list(x for x in some_seq). Важно, что после этого по генератору уже нельзя будет итерироваться.


52. Что возвращает итерация по словарю?


52) Ключ. Порядок следования ключей не гарантируется. Для маленьких словарей порядок будет тот же, что и в объявлении. Для больших порядок зависит от расположения элементов в памяти. Особый класс OrderedDict учитывает порядок добавления ключей.


53. Как итерировать словарь по парам ключ-значение?


53) Метод словаря .iteritems() возвращает генератор кортежей (key, value).


54. Как получить список атрибутов объекта?


54) Функция dir возвращает список строк – полей объекта. Поле __dict__ содержит словарь вида {поле -> значение}.


55. Как в классе сослаться на родительский класс?


55) Функция super принимает класс и экземпляр.


56. Возможно ли множественное наследование? Что такое MRO?


56) Да, можно указать более одного родителя в классе потомка.
MRO – method resolution order, порядок разрешения методов. Алгоритм, по которому следует искать метод в случае, если у класса два и более родителей. Алгоритм линеизирует граф наследования. Коротко можно описать так: ищи слева направо. Поэтому чем правее стоит класс, тем меньше у него приоритет при поиске метода.


57. Что такое GIL? Как работает? Какие проблемы?


57) Global Interpreter Lock. Особенность интерпретатора, когда одновременно может исполняться только один тред. Все это время остальные треды простаивают. GIL есть не только в Питоне, но и в других скриптовых языках, например, Руби.

Причина существования GIL в том, что для этих интерпретаторов еще не найден безопасный способ согласовывать изменения данных. Например, если один тред удалит все элемены из списка, а второй начнет итерацию по нему, гарантированно произойдет ошибка.

GIL работает так: на каждый тред выделяется некоторый квант времени. Он измеряется в машинных единицах “тиках” и по умолчанию равен 100. Как только на тред было потрачено 100 тиков, интерпретатор бросает этот тред и переключается на второй, тратит 100 тактов на него, затем третий, и так по кругу. Этот алгоритм гарантрует, что всем тредам будет выделено ресурсов поравну.

Проблема в том, что из-за GIL далеко не все задачи могут быть решены в тредах. Напротив, их использование чаще всего снижает быстродействие программы. С использованием тредов требуется следить за доступом к общим ресурсам: словарям, файлам, соединением к БД.


58. Какие задачи хорошо параллелятся, какие плохо?


58) Те задачи, которые порождают долгий IO. Когда тред упирается в ожидание сокета или диска, интерпретатор бросает этот тред и стартует следующий. Это значит, не будет простоя из-за ожидания. Наоборот, если ходить в сеть в одном треде (в цикле), то каждый раз придется ждать ответа.

Однако, если затем в треде обрабатывает полученные данные, то выполнятся будет только он один. Это не только не даст прироста в скорости, но и замедлит программу из-за переключения на другие треды.

Короткий ответ: хорошо ложатся на треды задачи по работе с сетью. Например, выкачать сто урлов. Полученные данные обрабатывайте вне тредов.


59. Нужно посчитать 100 уравнений. Делать это в тредах или нет?


59) Нет, потому что в этой задаче нет ввода-вывода. Интерпретатор только будет тратить лишнее время на переключение тредов. Сложные математические задачи лучше выносить в отдельные процессы, либо использовать фреймворк для распределенных задач Celery, либо подключать как C-библиотеки.


60. Что такое гринлеты? Общее понятие. Примеры реализаций.


60) Greenlet == Green thread == Зеленые треды == легковесные треды внутри виртуальной машины. Могут называться корутинами, сопроцессами, акторами и т.д. в зависимости от платформы. Операционная система не видит их. С точки зрения ОС запущен один процесс виртуальной машины, а что внутри нее – неизвестно. Такими тредами управляет сама вируальная машина: порождает, исполняет, согласует доступ к ресурсам.

Примеры: корутины в языках Go и Lua, легковесные процессы в Erlang, модуль greenlet для Python.


61. Что такое Middleware, для чего, как реализуется?


61) Middleware – особый объект, который изменяет входящий запрос или исходящий ответ. Например, добавляет заголовки, делает предварительные проверки. Middleware нужен, когда требуется подвергнуть обработке все запросы приложения.

На уровне языка это объект с методами process_request и process_response. Методы должны вернуть принятый объект (запрос или ответ) для дальнейшей обработки или выкинуть исключение, если что-то не в порядке. В этом случает дальнейшая обработка прекращается.

Чтобы включить Middleware, достаточно добавить путь к нему в кортеж MIDDLEWARE_CLASSES.


62. Назовите основные мидлвари? Зачем они нужны?


62) SessionMiddleware – поддержка сессий. Добавляет в запрос объект session
CsrfViewMiddleware – проверяет, что POST-запросы отправлены с текущего домена
AuthenticationMiddleware – авторизует пользователя. Добавляет в запрос поле user
MessageMiddleware – передает пользователю короткие сообщения


63. Опишите алгоритм работы CSRF middleware


63) На каждый запрос система генерирует уникальный токен и выставляет его в куках. В каждой форме размещается скрытое поле csrf-token с этим же токеном. При отправке формы методом POST Джанго проверяет, что поле формы и значение в куках совпадают. Если нет, это значит, что запрос подделан или отправлен с другого домена.

Чтобы освободить какую-то вьюху от проверки (если это API, например), достаточно обернуть ее декоратором csrf_except.


64. Чем лучше отправлять форму — GET или POST?


64) Форму можно отправлять обоими способами. В первом случае переменные прикрепляются к строке запроса после вопросительного знака. Во втором – передаются в теле запроса.

Техническое ограничение метода GET в том, что им нельзя передать файл, в отличие от POST.

Форму желательно передавать методом POST по следующим причинам:

GET-запросы могут быть кешированы, особенно в браузерах семейства IE
GET-запросы оседают в логах провайдера, сервера, истории браузера. Пароль и логин засветиться во многих местах
некоторые вирусы отслеживают содержимое адресной строки и пересылают третьим лицам.


65. Что такое REST?


65) REST (Representational state transfer) – соглашение о том, как выстраивать сервисы. Под REST часто имеют в виду т.н HTTP REST API. Как правило, это веб-приложение с набором урлов – конечных точек. Урлы принимают и возвращают данные в формате JSON. Тип операции задают методом HTTP-запроса, например:

GET – получить объект или список объектов
POST – создать объект
PUT – обновить существующий объект
DELETE – удалить объект
HEAD – получить метаданные объекта
REST-архитектура актвивно использует возможности протокола HTTP, чтобы избежать т.н. “велосипедов” – собственных решений. Например, параметры кеширования передаются стандартными заголовками Cache, If-Modified-Since, ETag. Авторизациция – заголовком Authentication.


66. Что такое XSS? Примеры? Как защитить приложение?


66) XSS – межсайтовые запросы. Страница, подверженная уязвимости, вынуждает пользователя выполнить запрос к другой странице, либо запустить нежелательный js-код.

Например, пользователь отправил комментарий, в котором был код:

<script>alert('foo');</script>
Движок сайта не фильтрует текст комментария, поэтому тег <script> становится частью страницы и исполняется браузером. Каждый, кто зайдет на страницу с опасным комментарием, увидет всплаывющее окно с тестом foo.

Другой пример. Страница поиска принимает поисковой терм q. В заголовке фраза “Результат поиска по запросу” + текст параметра. Если не экранировать параметр, то запрос /search?q=<script>alert('foo');</script> приведет к аналогичному результату.

Зная, что страница выполняет js-код, хакер может подгрузить на страницу контекстную рекламу, баннеры, заставить браузер перейти на любую страницу, похитить куки.

Уязвимость устраняется экранированием небезопасных символов, чисткой (санацией) HTML-тегов.


67. Что такое CGI? Плюсы, минусы?


67) Common Gateway Interface. Соглашение о том, как веб-сервер взаимодействует с программой, написанной на каком-то языке. Веб-сервер запускает программу как исполняемый файл. Параметры запроса, например, метод, путь, заголовки и т.д. передаются через переменные окружения.

Программа должна прочитать эти переменные и записать в стандартный поток вывода HTTP-ответ.

Плюсы:

Протокол не накладывает условия на язык, на котором написана программа. Это может быть и скрипт, и бинарный файл.
Протокол экстремально прост.
Программа не хранит состояние, что удобно для отладки.
Минусы:

Запуск процесса ОС на каждый запрос отрабатывает очень медленно.
Передача данных через stdout медленней юникс-сокетов.


68. Что такое CSRF?


68) Сross Site Request Forgery (межсайтовая подделка запроса). Вид уязвимости, когда сайт А вынуждает пользователя выполнить запрос на сайт Б. Это может быть тег img или script для GET-запроса, или форма со специальным атрибутом target.

Чтобы предотвратить уязвимость, сайт Б должен убедиться, что запрос пришел именно с его страницы.

Например, пользователь должен заполнить форму. В нее помещают скрытое поле token – одноразовую последовательность символов. Этот же токен сохраняют в куки пользователя. При отправке формы поле и куки должны совпасть. Способ не является надежным и обходится скриптом.


69. Как защитить куки от воровства и от подделки?


69) Зависит от того, насколько строгие критерии безопасности на сайте. Если в куках хранятся вспомогательные данные, например, индекс последнего выбранного в дропдауне элемента, правилами ниже можно пренебречь.

Для платежных систем, сайтов с приватными данными приведенные правила обязательны.

Выставлять кукам флаг httponly. Браузер не даст прочесть и изменить такие куки на клиенте Джаваскриптом.
Использовать флаг secure. Куки будут переданы только по безопасному соединению.
Устанавливать короткий срок жизни куки.
Устанавливать короткий срок сессии на сервере.
Добавлять в ключ сессии заголовок User-Agent. Тогда если украсть куки и установить на другой машине, ключ сессии будет другим.
Аналогично пункту выше, но добавлять IP пользователя.
Подписывать куки секретным ключом. Добавлять поле sig, которое равно HMAC-SHA1(cookie-body, secret_key). На сервере проверять, что подпись совпадает.


70. Как устроен протокол HTTP?


70) HTTP – текстовый протокол, работающий поверх TCP/IP. HTTP состоит из запроса и ответа. Их структуры похожи: стартовая строка, заголовки, тело ответа.

Стартовая строка запроса состоит из метода, пути и версии протокола:

GET /index.html HTTP/1.1
Стартовая строка ответа состоит из версии протокола, кода ответа и текстовой расшифровке ответа.

HTTP/1.1 200 OK
Заголовки – это набор пар ключ-значение, например, User-Agent, Content-Type. В заголовках передают метаданные запроса: язык пользователя, авторизацию, перенаправление. Заголовок Host должен быть в запросе всегда.

Тело ответа может быть пустым, либо может передавать пары переменных, файлы, бинарные данные. Тело отделяется от заголовков пустой строкой.


71. Как клиенту понять, удался запрос или нет?


71) Проверить статус ответа. Ответы разделены по старшему разряду. Имеем пять групп со следующей семантикой:

1xx: используется крайне редко. В этой группе только один статус 100 Continue.
2xx: запрос прошел успешно (данные получены или созданы)
3xx: перенаправление на другой ресурс
4xx: ошибка по вине пользователя (нет такой страницы, нет прав на доступ)
5xx: ошибка по вине сервера (ошибка в коде, сети, конфигурации)


72. Как управлять кешированием в HTTP?


72) Существуют несколько способов кешировать данные на уровне протокола.

Заголовки Cache и Cache-Control регулируют сразу несколько критериев кеша: время жизни, политику обновления, поведение прокси-сервера, тип данных (публичные, приватные).
Заголовки Last-Modified и If-Modified-Since задают кеширование в зависимости от даты обновления документа.
Заголовок Etag кеширует документ по его уникальному хешу.


73. Как кэшируются файлы на уровне протокола?


73) Когда Nginx отдает статичный файл, он добавляет заголовок Etag – MD5-хеш файла. Клиент запоминает этот хеш. В следующий раз при запросе файла клиент посылает хеш. Сервер проверяет хеш клиента для этого файла. Если хеш не совпадает (файл обновили), сервер отвечает с кодом 200 и выгружает актуальный файл с новым хешем. Если хеши равны, сервер отвечает с кодом 304 Not Modified с пустым телом. В этом случае браузер подставляет локальную копию файла.


74. Что делает оператор HAVING, примеры?


74) Оператор SQL HAVING является указателем на результат выполнения агрегатных функций. Агрегатной функцией в языке SQL называется функция, возвращающая какое-либо одно значение по набору значений столбца. Такими функциями являются: SQL COUNT(), SQL MIN(), SQL MAX(), SQL AVG(), SQL SUM().


75. Что такое SQL-инъекции, какие меры против?


75) Внедрение SQL-кода (SQL инъекция) — один из распространённых способов взлома сайтов, работающих с базами данных. Способ основан на внедрении в запрос произвольного SQL-кода.
Внедрение SQL позволяет хакеру выполнить произвольный запрос к базе данных (прочитать содержимое любых таблиц, удалить, изменить или добавить данные).
Атака этого типа возможна, когда недостаточно фильтруются входные данные при использовании в SQL-запросах.


76. Что такое хвостовая рекурсия?


76) Это особый вид рекурсии, когда функция заканчивается вызовом самой себя без дополнительных операторов. Когда это условие выполняется, компилятор разворачивает рекурсию в цикл с одним стек-фреймом, просто меняя локальные переменные от итерации к итерации.

Так, классическое определение рекурсивного факториала return N * fact(N - 1) не поддерживает хвостовую рекурсию, потому что для каждого стек-фрейма придется хранить текущее значение N.

Чтобы сделать рекурсии хвостовой, добавляют параметры-аккумуляторы. Благодаря им функция знает о своем текущем состоянии.


77. Опишите быструю сортировку. Какова ее сложность?


77) На первом этапе выбирают опорный элемент. Чаще всего его берут из середины массива. Затем последовательно сравнивают первый элемент массива с последним, второй с предпоследним и т.д. Если элемент слева от опорного элемента больше правого, они меняются местами. Когда доходят до опорного элемента, итерация считается законченной.

Далее описанный выше алгоритм применяют для двух подмассивов. Первый – от первого элемента до опорного элемента (не включительно), второй – от опорного до последнего.

Рекурсивный спуск продолжается, пока длины подмассивов не станут равны единице.

Сложность быстрой сортировки в среднем случае равна N * log(N).


78. Главные различия между Python 2 и Python 3


78) Дата выпуска	  2008	                                                                             2000
Функция вывода	          print("hello")	                                                             print "hello"
Деление целых чисел	  При делении целых чисел результатом является вещественное число.	             При делении целых чисел результатом является также целое число.
Юникод	                  В Python 3 строки по умолчанию хранятся как Юникод (Unicode).	                     Для хранения значения строки как Юникод (Unicode) требуется определить ее с «u».
Синтаксис	          Синтаксис проще и легче для понимания.	                                     Синтаксис в Python 2 несколько сложнее для понимания.
Итерация	          Введена новая функция range() для итераций.	                                     В Python 2 для итераций используется xrange().
Исключения	          Должны быть заключены в круглые скобки.	                                     Заключаются в примечаниях (notations).
Переменные	          Значение переменных не меняется.	                                             Глобальная переменная изменяется в цикле for при совпадении имён.


79. Что такое new() и чем он отличается от init()


79) В Python __new__ используется для инициализации неизменяемых типов, а __init__ обычно инициализирует изменяемые типы.


80. Что такое mocking?


80) Mock — это просто объект, который создает пустой тест для определенной части программы.

Вместо вызова обычной проверки, вы вызываете mock и смотрите, как проходит тест какая-то часть программы.


81. Что делать, если тестируемая функция использует удалённое подключение к внешним сервисам, которое иногда видает ошибку таймаута, 404 и им подобные?


81) Если мы говорим про юнит тесты, то они не должны вызывать внешние ресурсы, то есть делать http запросы и тд. Следовательно нужно либо замокать http-клиент, который использует функция для вызова сервиса, либо, что обычно является лучшим решением, передавать то что вызывает этот сервис в функцию зависимостью (если конечно мы не тестируем сам клиент для вызова сервиса).


82. Что делать, если тестируемая функция занимает много времени на выполнение повторяющихся операций внутри неё?


82) В таком случае я бы:
сделал бы возможным заменить из теста верхнюю границу цикла (через параметр или мокая константу, настройку и т.д.)
если функция вызывает для расчетов другую ресурсоёмкую функцию, стороннюю или из своей кодовой базы, то возможно замокал бы ее и проверил что она вызывается с нужными параметрами
по возможности подготовил бы для теста такой входящий набор данных, при котором она выполялась быстро
Если функция не соответсвует условиям, описанным в первом предложении, следовало бы сначала заняться ее декомпозицие


83. Какая разница между одинарным (_) и двойным (__) подчеркиванием?


83)Одинарное начальное подчеркивание(_var) : Соглашение об именовании, указывающее, что имя предназначено для внутреннего использования. Обычно не применяется интерпретатором Python (за исключением импорта подстановочных знаков) и предназначен только для подсказки программисту.
Одиночное подчеркивание Trailing(var_) : используется по соглашению, чтобы избежать конфликтов имен с ключевыми словами Python.
Двойное начальное подчеркивание(__var) : вызывает искажение имени при использовании в контексте класса. Принудительно исполняется интерпретатором Python.
Двойное начальное и Trailing подчеркивание(__var__) : указывает на специальные методы, определенные языком Python. Избегайте этой схемы именования для ваших собственных атрибутов.
Одиночное подчеркивание(_) : иногда используется как имя для временных или незначительных переменных (“мне все равно”). Также: результат последнего выражения в a Python REPL.


84. Что такое GIL?


84) Python Global Interpreter Lock (GIL) — это своеобразная блокировка, позволяющая только одному потоку управлять интерпретатором Python. Это означает, что в любой момент времени будет выполняться только один конкретный поток.
Работа GIL может казаться несущественной для разработчиков, создающих однопоточные программы. Но во многопоточных программах отсутствие GIL может негативно сказываться на производительности процессоро-зависымых программ.


85. GIL какие у него есть проблемы?


85) Из-за GIL в конкретный момент времени выполнять байт-код Python может лишь один поток операционной системы. В результате нельзя ускорить Python-код, интенсивно использующий ресурсы процессора, распределив вычислительную нагрузку по нескольким потокам. Негативное влияние GIL на производительность Python-программ, правда, на этом не заканчивается. Так, GIL создаёт дополнительную нагрузку на систему. Это замедляет многопоточные программы и, что выглядит достаточно неожиданно, может даже оказать влияние на потоки, производительность которых ограничена подсистемой ввода/вывода.


86. Зачем нужен Celery?


86) Celery – это система для управления очередями задач. Принципиально умеет 2 вещи: брать задачи из очереди и выполнять задачи по расписанию. В качестве брокера очередей обычно используются RabbitMQ или Redis. В очереди кладутся задачи, а потом воркеры Celery берут их оттуда и выполняют.


87. Как работает Serializer в Django REST Framework?


87) Сериализаторы в REST framework работают аналогично классам Django Form и ModelForm. Мы предоставляем класс Serializer, который дает вам мощный, общий способ управления вашими ответами, а также класс ModelSerializer- полезный и быстрый способ создания сериализаторов, которые имеют дело с экземплярами модели и querysets.


88. За что отвечает Meta в сериализаторе?


88) Класс Meta позволяет указать модель для сериализации и поля, включаемые в сериализацию. Все поля модели будут включены, если не задан атрибут fields. Как можно видеть, данные модели переводятся в нативные типы данных Python.


89. Как в django работает система аутентификации?


89) Система аутентификации Django отвечает за оба аспекта: аутентификацию и авторизацию. Если коротко, то аутентификация проверяет пользователя, а авторизация определяет, что аутентифицированный пользователь может делать. Далее термин “аутентификация” будет использоваться для обозначения обоих аспектов.

Система аутентификации состоит из:

Пользователей

Прав: Бинарные (да/нет) флаги, определяющие наличие у пользователя права выполнять определённые действия.

Групп: Общий способ назначения меток и прав на множество пользователей.

Настраиваемой системы хеширования паролей

Инструментов для форм и представлений для аутентификации пользователей или для ограничения доступа к контенту

Системы плагинов

Аутентификационная система Django старается быть очень простой и не предоставляет некоторые фичи, распространённые в других системах веб аутентификации. Такие фичи реализованы в сторонних пакетах:

Проверка сложности пароля

Ограничение попыток входа

Аутентификация через сторонние сервисы (OAuth, например)


90. Как в django обрабатывается (и генерируется) CSRF-token?


90)  Если жертва заходит на сайт, созданный злоумышленником, от её лица тайно отправляется запрос на другой сервер (например, на сервер платёжной системы), осуществляющий некую вредоносную операцию (например, перевод денег на счёт злоумышленника). Для осуществления данной атаки жертва должна быть аутентифицирована на том сервере, на который отправляется запрос, и этот запрос не должен требовать какого-либо подтверждения со стороны пользователя, которое не может быть проигнорировано или подделано атакующим скриптом. Атака осуществляется путём размещения на веб-странице ссылки или скрипта, пытающегося получить доступ к сайту, на котором атакуемый пользователь заведомо (или предположительно) уже аутентифицирован.


91. Что такое куки? Зачем они, как с ними работать и где они сохраняются?


91) Cookies — это небольшие текстовые файлы у нас на компьютерах, в которых хранится информация о наших предыдущих действиях на сайтах. Кроме входов в аккаунты они умеют запоминать:

предпочтения пользователей, например, язык, валюту или размер шрифта.
товары, которые мы просматривали или добавили в корзину;
текст, который мы вводили на сайте раньше;
IP-адрес и местоположение пользователя;
дату и время посещения сайта;
версию ОС и браузера;
клики и переходы.

Когда мы совершаем на сайте какое-то действие, например, добавляем товар в корзину или вводим детали входа в аккаунт, сервер записывает эту информацию в куки и отправляет браузеру вместе со страницей. Когда мы переходим на другую страницу сайта или заходим на него через время, браузер отправляет куки обратно.

Куки бывают временными и постоянными. Постоянные куки остаются на компьютере, когда мы закрываем вкладку с сайтом, а временные удаляются. Какие именно куки использовать на конкретном сайте — временные или постоянные — решает его разработчик. Именно поэтому на одних сайтах мы не выходим из аккаунтов, даже когда заходим на них раз спустя несколько дней, а на других вводим пароль заново, хотя отошли от компьютера на пять минут.


92. Что такое JWT (JSON Web Token)?


92) JSON Web Token (JWT) — это открытый стандарт (RFC 7519) для создания токенов доступа, основанный на формате JSON. Как правило, используется для передачи данных для аутентификации в клиент-серверных приложениях. Токены создаются сервером, подписываются секретным ключом и передаются клиенту, который в дальнейшем использует данный токен для подтверждения своей личности.
Токен JWT состоит из трех частей: заголовка (header), полезной нагрузки (payload) и подписи или данных шифрования. Первые два элемента — это JSON объекты определенной структуры. Третий элемент вычисляется на основании первых и зависит от выбранного алгоритма (в случае использования неподписанного JWT может быть опущен). Токены могут быть перекодированы в компактное представление (JWS/JWE Compact Serialization): к заголовку и полезной нагрузке применяется алгоритм кодирования Base64-URL, после чего добавляется подпись и все три элемента разделяются точками («.»).


93. Какие системы контроля версий Вы знаете (используете)?


93) Git — это распределённая система версий
Системы контроля версий бывают локальными, централизованными или распределёнными.

Локальная система хранит файлы на одном устройстве, централизованная использует общий сервер, а распределённая — общее облачное хранилище и локальные устройства участников команды. В локальной системе удобно работать с большими проектами, но сложно взаимодействовать с удалённой командой.
В централизованной системе налажена удалённая работа, но всё привязано к одному серверу. Любой сбой или взлом может повредить файлы проекта.
В распределённой системе налажена удалённая работа. Если с файлами основного репозитория что-то случится — проект легко восстановить из копии любого участника команды.
Git — это программа, которую нужно установить и подключить к проекту для управления системой контроля версий. GitHub — это сайт-хранилище для историй версий проектов: вы подключаете Git, регистрируетесь на GitHub, создаёте онлайн-репозиторий и переносите файлы с Git на GitHub.

Git — это самая популярная система контроля версий, а GitHub — онлайн-хранилище кода. Git и GitHub настроены на взаимодействие и поэтому часто используются как единый механизм работы с проектом.

Если нужно, Git можно заменить альтернативной программой контроля версий, а GitHub — другим онлайн-хранилищем кода. Большинству работодателей это не нужно, поскольку знакомство с другими сервисами отнимает время и неудобно многим разработчикам.


94. Что такое Git Flow?


94) Git-flow — альтернативная модель ветвления Git, в которой используются функциональные ветки и несколько основных веток. Эта модель была впервые опубликована и популяризована Винсентом Дриссеном на сайте nvie. По сравнению с моделью магистральной разработки, в Git-flow используется больше веток, каждая из которых существует дольше, а коммиты обычно крупнее. В соответствии с этой моделью разработчики создают функциональную ветку и откладывают ее слияние с главной магистральной веткой до завершения работы над функцией. Такие долгосрочные функциональные ветки требуют тесного взаимодействия разработчиков при слиянии и создают повышенный риск отклонения от магистральной ветки. В них также могут присутствовать конфликтующие обновления.

Git-flow можно использовать для проектов, в которых запланирован цикл релизов и реализуется характерная для DevOps методика непрерывной поставки. В этом рабочем процессе используются понятия и команды, которые были предложены в рамках рабочего процесса с функциональными ветками. Однако Git-flow привносит новые специфические роли для разных веток и определяет характер и частоту взаимодействия между ними. Помимо функциональных веток в рамках этого рабочего процесса используются отдельные ветки для подготовки, поддержки и регистрации релизов. При этом вы по-прежнему можете пользоваться преимуществами рабочего процесса с функциональными ветками, такими как запросы pull, изолированные эксперименты и эффективное командное взаимодействие.


95. Что такое Git Rebase?


95) Rebase — еще один способ перенести изменения из одной ветки в другую. Rebase сжимает все изменения в один «патч». Затем он интегрирует патч в целевую ветку.

В отличие от слияния, перемещение перезаписывает историю, потому что она передает завершенную работу из одной ветки в другую. В процессе устраняется нежелательная история.

Плюсы:

Упрощает потенциально сложную историю
Упрощение манипуляций с единственным коммитом
Избежание слияния коммитов в занятых репозиториях и ветках
Очищает промежуточные коммиты, делая их одним коммитом, что полезно для DevOps команд

Минусы:

Сжатие фич до нескольких коммитов может скрыть контекст
Перемещение публичных репозиториев может быть опасным при работе в команде
Появляется больше работы
Для восстановления с удаленными ветками требуется принудительный пуш. Это приводит к обновлению всех веток, имеющих одно и то же имя, как локально, так и удаленно, и это ужасно.


96. Что такое pre commit check?


96) Хуки уровня коммита
Первые четыре хука работают во время создания коммитов.

Первым запускается pre-commit хук, до того как вы напечатаете сообщение коммита. Он используется для проверки данных перед созданием коммита и позволяет увидеть если вы что-то забыли, запустить тесты, или выполнить другую необходимую проверку кода. Создание коммита будет отменено если выполнение хука завершится с кодом отличным от нуля. Пропустить выполнение хука можно с помощью git commit --no-verify. С помощью этого хука можно проверять стиль кода (запустить lint или аналог), проверять наличие пробелов в конце строк (именно это делает стандартный хук) или проверять наличие документации для новых методов.

Хук prepare-commit-msg запускается до вызова редактора сообщения коммита, но после создания стандартного сообщения. Это позволяет вам изменить стандартное сообщение коммита до того, как автор коммита увидит его. Хук принимает несколько параметров: путь к файлу, содержащему сообщение коммита, тип коммита и SHA-1-хеш, если текущий коммит является исправлением существующего. Для обычных коммитов этот хук бесполезен, однако находит своё применение для коммитов, где сообщение генерируется автоматически, например, для сообщений на основе шаблонов, коммитов слияния, сжимаемых и исправляемых коммитов. Его можно использовать для программного заполнения шаблона коммита необходимой информацией.

Хук commit-msg принимает один параметр — путь к временному файлу, содержащему указанное разработчиком сообщение коммита. Если скрипт завершается с ненулевым кодом, то Git отменяет создание коммита, поэтому вы можете использовать этот хук для валидации состояния проекта или сообщения коммита до того как он будет создан. В последнем разделе этой главы мы покажем как использовать этот хук для проверки сообщения коммита на соответствие заданному шаблону.

Хук post-commit запускается после того, как коммит создан. Он не принимает никаких параметров, но вы можете легко получить информацию о последнем коммите выполнив git log -1 HEAD. Обычно, этот скрипт используется для уведомлений или чего-то подобного.


97. Что такое вложенные транзакции?


97) Вложенными называются транзакции, выполнение которых инициируется в теле уже активной транзакции.

Для создания вложенной транзакции не используются какие- либо дополнительные операторы. В программе на языке SQL просто начинается новая транзакция (оператор BEGIN TRAN), без закрытия текущей транзакции (операторы COMMIT или ROLLBACK). Завершение текущей транзакции (или транзакции верхнего уровня) откладывается до завершения вложенной транзакции. При этом внутри новой (вложенной) транзакции могут открываться новые транзакции и, таким образом, образуется иерархия вложенных транзакций. Если транзакция самого нижнего (вложенного) уровня завершена неудачно и отменена, то все транзакции верхнего уровня, включая транзакцию первого уровня, будут отменены.

Кроме того, если несколько транзакций нижнего уровня были завершены успешно, однако на среднем уровне (не самая верхняя транзакция) неудачно завершилась другая транзакция, то в соответствии с требованиями АСЮ произойдет откат всех транзакций всех уровней, включая успешно завершенные. Вложенные транзакции могут быть следующих видов:

Псевдо-вложенные транзакции
Вложенная субтранзакция
Вложенная независимая транзакция


98. Что такое курсор и зачем он нужен?


98) Курсор — ссылка на контекстную область памяти. В некоторых реализациях языка программирования SQL (Oracle, Microsoft SQL Server) — получаемый при выполнении запроса результирующий набор и связанный с ним указатель текущей записи. бы сказал, что курсор — это виртуальная таблица которая представляет собой альтернативное хранилище данных. При этом курсор, позволяет обращаться к своим данным, как к данным обычного массива. Используются курсоры в хранимых процедурах.


99. Какая разница между PostgreSQL и MySQL?


99) MySQL — это реляционная система управления базами данных с открытым кодом, которая разрабатывается компанией Oracle. Этот код можно получить бесплатно используя лицензию GNU, а также коммерческие версии MySQL доступны под различными соглашениями.

PostgreSQL — это объектно-реляционная СУБД, которая разработана Global Group. Она также имеет открытый исходный код. Основные различия между этими двумя моделями СУБД:

управление;
поддержка платформ;
методы доступа;
секционирование;
репликация.
Управление в этих двух моделях баз данных является одним из наиболее существенных различий. MySQL управляется Oracle, тогда как Postgres доступен по лицензии с открытым исходным кодом от Global Group. Таким образом, наблюдается повышение интереса к PostgreSQL в последние несколько лет.


100. Что такое VACUUM в PostgreSQL?


100) VACUUM — оператор, который проводит сборку мусора и, возможно, анализирует базу данных. VACUUM высвобождает пространство, занимаемое «мёртвыми» кортежами. При обычных операциях PostgreSQL кортежи, удалённые или устаревшие в результате обновления, физически не удаляются из таблицы; они сохраняются в ней, пока не будет выполнена команда VACUUM. Таким образом, периодически необходимо выполнять VACUUM, особенно для часто изменяемых таблиц.

Без параметра команда VACUUM обрабатывает все таблицы в текущей базе данных, которые может очистить текущий пользователь. Если в параметре передаётся имя таблицы, VACUUM обрабатывает только эту таблицу.

VACUUM ANALYZE выполняет очистку (VACUUM), а затем анализ (ANALYZE) всех указанных таблиц. Это удобная комбинация для регулярного обслуживания БД. За дополнительной информацией об анализе обратитесь к описанию ANALYZE.


101. Что такое MapReduce и как он работает?


101) MapReduce — модель распределённых вычислений, представленная компанией Google, используемая для параллельных вычислений над очень большими, вплоть до нескольких петабайт[1], наборами данных в компьютерных кластерах. MapReduce — это фреймворк для вычисления некоторых наборов распределенных задач с использованием большого количества компьютеров (называемых «нодами»), образующих кластер.

Работа MapReduce состоит из двух шагов: Map и Reduce, названных так по аналогии с одноименными функциями высшего порядка, map и reduce.

На Map-шаге происходит предварительная обработка входных данных. Для этого один из компьютеров (называемый главным узлом — master node) получает входные данные задачи, разделяет их на части и передает другим компьютерам (рабочим узлам — worker node) для предварительной обработки.

На Reduce-шаге происходит свёртка предварительно обработанных данных. Главный узел получает ответы от рабочих узлов и на их основе формирует результат — решение задачи, которая изначально формулировалась.


102. Какая разница между Hive и HBase?


102) Ключевые различия между Hive и HBase
Hbase совместим с кислотой, а Hive - нет.
Hive поддерживает критерии разбиения и фильтрации на основе формата даты, тогда как HBase поддерживает автоматическое разбиение.
Hive не поддерживает операторы обновления, тогда как HBase поддерживает их.
Hbase быстрее по сравнению с Hive при получении данных.
Hive используется для обработки структурированных данных, тогда как HBase, поскольку он не содержит схем, может обрабатывать данные любого типа.
Hbase обладает высокой (горизонтальной) масштабируемостью по сравнению с Hive.
Hive анализирует данные в HDFS с поддержкой SQL-запросов, а затем преобразует их в карту и сокращает количество заданий, тогда как в Hbase, поскольку потоковая передача выполняется в режиме реального времени, он непосредственно выполняет свои операции с базой данных, разбивая таблицы и семейства столбцов.
когда мы обращаемся к запросам данных, куст использует оболочку, известную как оболочка Hive, для выдачи команд, тогда как HBase, поскольку это база данных, мы будем использовать команду для обработки данных в HBase.
Чтобы перейти к оболочке Hive, мы будем использовать команду hive. После этого он будет выглядеть как куст>. В HBase мы просто указываем как Use HBase.


103. Что такое  host?


103) Хост — это определенный компьютер или сервер, подключенный к локальной или глобальной сети. Хост обладает уникальным адресом в среде сервисов TCP/IP (IP-адрес, Internet Protocol Address). Хосты — число уникальных показов. В сфере интернет маркетинга слово “хост” имеет несколько значений. Прежде всего, это сервер, предоставляющий услугу размещения определенной информации, различных файлов, как предназначенных для личного пользования, так и открытых сетей. Хост – это параметр, который применяется для оценки уровня посещаемости сайта. Он показывает количество посетителей на сайте, перешедших с уникальных IP, то есть у посетителей должны быть разные IP-адреса.
IP-адрес не показывает уникальный компьютер, с которого зашли на интернет-ресурс. Он показывает адрес узла. То есть, с одного и того же IP могут заходить физически разные посетители, однако система их примет за один хост.


104. Что такое API?


104) API, Application Programming Interface (программный интерфейс приложения), — описание способов (набор классов, процедур, функций, структур или констант), которыми одна компьютерная программа может взаимодействовать с другой программой. Обычно входит в описание какого-либо интернет-протокола (например, RFC[2]), программного каркаса (фреймворка)[3] или стандарта вызовов функций операционной системы[4]. Часто реализуется отдельной программной библиотекой или сервисом операционной системы. Используется программистами при написании всевозможных приложений. API (интерфейс прикладного программирования) упрощает процесс программирования при создании приложений, абстрагируя базовую реализацию и предоставляя только объекты или действия, необходимые разработчику. Если графический интерфейс для почтового клиента может предоставить пользователю кнопку, которая выполнит все шаги для выборки и выделения новых писем, то API для ввода/вывода файлов может дать разработчику функцию, которая копирует файл из одного места в другое, не требуя от разработчика понимания операций файловой системы, происходящих за кулисами. 


105. Что такое MVC?


105) Model-View-Controller (MVC, «Модель-Представление-Контроллер», «Модель-Вид-Контроллер») — схема разделения данных приложения, и управляющей логики на три отдельных компонента: модель, представление и контроллер — таким образом, что модификация каждого компонента может осуществляться независимо.

Модель (Model) предоставляет данные и реагирует на команды контроллера, изменяя своё состояние.
Представление (View) отвечает за отображение данных модели пользователю, реагируя на изменения модели.
Контроллер (Controller) интерпретирует действия пользователя, оповещая модель о необходимости изменений.

Основная цель применения этой концепции состоит в отделении бизнес-логики (модели) от её визуализации (представления, вида). За счёт такого разделения повышается возможность повторного использования кода. Наиболее полезно применение данной концепции в тех случаях, когда пользователь должен видеть те же самые данные одновременно в различных контекстах и/или с различных точек зрения. В частности, выполняются следующие задачи:

К одной модели можно присоединить несколько видов, при этом не затрагивая реализацию модели. Например, некоторые данные могут быть одновременно представлены в виде электронной таблицы, гистограммы и круговой диаграммы;
Не затрагивая реализацию видов, можно изменить реакции на действия пользователя (нажатие мышью на кнопке, ввод данных) — для этого достаточно использовать другой контроллер;
Ряд разработчиков специализируется только в одной из областей: либо разрабатывают графический интерфейс, либо разрабатывают бизнес-логику. Поэтому возможно добиться того, что программисты, занимающиеся разработкой бизнес-логики (модели), вообще не будут осведомлены о том, какое представление будет использоваться.


106. Что такое GET запрос Python?


106) GET является одним из самых популярных HTTP методов. Метод GET указывает на то, что происходит попытка извлечь данные из определенного ресурса. Для того, чтобы выполнить запрос GET, используется requests.get(). Для проверки работы команды будет выполнен запрос GET в отношении Root REST API на GitHub. Requests - это модуль Python, который вы можете использовать для отправки всех видов HTTP-запросов. Это простая в использовании библиотека с множеством функций, начиная от передачи параметров в URL-адресах до отправки пользовательских заголовков и проверки SSL. 


107. Что такое классы в Python.


107) Класс — тип, описывающий устройство объектов. Объект — это экземпляр класса. Класс можно сравнить с чертежом, по которому создаются объекты.

Python соответствует принципам объектно-ориентированного программирования. В python всё является объектами - и строки, и списки, и словари, и всё остальное.

Но возможности ООП в python этим не ограничены. Программист может написать свой тип данных (класс), определить в нём свои методы.

Это не является обязательным - мы можем пользоваться только встроенными объектами. Однако ООП полезно при долгосрочной разработке программы несколькими людьми, так как упрощает понимание кода.

Класс является шаблоном или формальным описанием объекта, а объект представляет экземпляр этого класса, его реальное воплощение. Можно провести следующую аналогию: у всех у нас есть некоторое представление о человеке - наличие двух рук, двух ног, головы, пищеварительной, нервной системы, головного мозга и т.д. Есть некоторый шаблон - этот шаблон можно назвать классом. Реально же существующий человек (фактически экземпляр данного класса) является объектом этого класса.

С точки зрения кода класс объединяет набор функций и переменных, которые выполняют определенную задачу. Функции класса еще называют методами. Они определяют поведение класса. А переменные класса называют атрибутами - они хранят состояние класса


108. Что такое self?


108) Параметр self указывался выше в определении методов, а также при использовании переменных экземпляра в методе. Параметр self это ссылка на конкретный экземпляр класса. При этом, само имя self не является особенным, а лишь договоренностью.


109. Является ли range() итератором?


109) range() не итератор и не генератор, для него работает оператор in, и есть специальные перегруженные магические методы.


110. Что происходит когда вводишь url?


110)

1. Пользователь вводит в браузере адрес сайта

2. Браузер начинает искать сервер
За работу любого сайта обычно отвечает один из миллионов серверов, подключенных к интернету. Адрес сервера — это уникальный набор цифр, который называется IP-адресом. Например, для vc.ru— это сервер 85.119.149.83.

Поэтому первым делом браузеру нужно понять, какой IP-адрес у сервера, на котором находится сайт.

Такая информация хранится в распределенной системе серверов — DNS (Domain Name System). Система работает как общая «контактная книга», хранящаяся на распределенных серверах и устройствах в интернете.

Однако перед тем, как обращаться к DNS, браузер пытается найти запись об IP-адресе сайта в ближайших местах, чтобы сэкономить время:

Сначала в своей истории подключений. Если пользователь уже посещал сайт, то в браузере могла сохраниться информация c IP-адресом сервера.
В операционной системе. Не обнаружив информации у себя, браузер обращается к операционной системе, которая также могла сохранить у себя DNS-запись. Например, если подключение с сайтом устанавливалось через одно из установленных на компьютере приложений.
В кэше роутера, который сохраняет информацию о последних соединениях, совершенных из локальной сети.
3. Браузер отправляет запрос к DNS-серверам
Не обнаружив подходящих записей в кэше, браузер формирует запрос к DNS-серверам, расположенным в интернете.

Например, если нужно найти IP-адрес сайта mail.vc.ru, браузер спрашивает у ближайшего DNS-сервера «Какой IP-адрес у сайта mail.vc.ru?».

Сервер может ответить: «Я не знаю про mail.vc.ru, но знаю сервер, который отвечает за vc.ru». Запрос переадресовывается дальше, на сервер «выше», пока в итоге один из серверов не найдет ответ об IP-адресе для сайта.
4. Браузер устанавливает соединение с сервером
Как только браузер узнал IP-адрес нужного сервера, он пытается установить с ним соединение. В большинстве случаев для этого используется специальный протокол — TCP.

TCP — это набор правил, который описывает способы соединения между устройствами, форматы отправки запросов, действия в случае потери данных и так далее.

Например, для установки соединения между браузером и сервером в стандарте TCP используется система «трёх рукопожатий». Работает она так:

Устройство пользователя отправляет специальный запрос на установку соединения с сервером — называется SYN-пакет.
Сервер в ответ отправляет запрос с подтверждением получения SYN-пакета — называется SYN/ACK-пакет.
В конце устройство пользователя при получении SYN/ACK-пакета отправляет пакет с подтверждением — ACK-пакет. В этот момент соединение считается установленным.
5. Браузер отправляет HTTP-запрос, чтобы получить контент сайта
После установки соединения браузер отправляет специальный запрос, в котором просит сервер отправить данные для отображения страницы. В этом запросе содержится информация о самом браузере, временные файлы, требования к соединению и так далее.

Задача браузера — как можно подробнее объяснить серверу, какая именно информация ему нужна.

В общении браузера и сервера выделяют два типа запросов. GET-запрос используется для получения данных с сервера — например, отобразить картинку, текст или видео. POST-запрос — используется для отправки данных из браузера на сервер, например, когда пользователь отправляет сообщение, картинку или загружает файл.

6. Сервер обрабатывает запрос
Сервер получил запрос от браузера с подробным описанием того, что ему требуется. Теперь ему нужно обработать этот запрос. Этой задачей занимается специальное серверное программное обеспечение — например, nginx или Apache. Чаще всего такие программы принято называть веб-серверами.

Веб-сервер в свою очередь перенаправляет запрос на дальнейшую обработку к программе-обработчику — например, PHP, Ruby или ASP.NET. Программа внимательно изучает содержимое запроса — например, понимает, в каком формате нужно отправить ответ и какие именно файлы нужны. И собирает ответ.

7. Сервер отправляет ответ браузеру
Когда ответ сформирован, он отправляется веб-сервером обратно браузеру. В ответе как правило содержится контент для отображения веб-страницы, информация о типе сжатия данных, способах кэширования, файлы cookie, которые нужно записать и так далее.

8. Браузер обрабатывает полученный ответ и «рисует» веб-страницу
Браузер распаковывает полученный ответ и постепенно начинает отображать полученный контент на экране пользователя — этот процесс называется рендерингом.

Сначала браузер загружает только основную структуру HTML-страницы. Затем последовательно проверяет все теги и отправляет дополнительные GET-запросы для получения с сервера различных элементов — картинки, файлы, скрипты, таблицы стилей и так далее. Поэтому по мере загрузки страницы браузер и сервер продолжают обмениваться между собой информацией.

Параллельно с этим на компьютер как правило сохраняются статичные файлы пользователя — чтобы при следующем посещении не загружать их заново и быстрее отобразить пользователю содержимое страницы.

Как только рендеринг завершен — пользователю отобразится полностью загруженная страница сайта.


111. 






















































































